//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.42000
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

namespace CodeCracker.Properties {
    using System;
    using System.Reflection;
    
    
    /// <summary>
    ///   Une classe de ressource fortement typée destinée, entre autres, à la consultation des chaînes localisées.
    /// </summary>
    // Cette classe a été générée automatiquement par la classe StronglyTypedResourceBuilder
    // à l'aide d'un outil, tel que ResGen ou Visual Studio.
    // Pour ajouter ou supprimer un membre, modifiez votre fichier .ResX, puis réexécutez ResGen
    // avec l'option /str ou régénérez votre projet VS.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Retourne l'instance ResourceManager mise en cache utilisée par cette classe.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("CodeCracker.Properties.Resources", typeof(Resources).GetTypeInfo().Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Remplace la propriété CurrentUICulture du thread actuel pour toutes
        ///   les recherches de ressources à l'aide de cette classe de ressource fortement typée.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à String interpolation allows for better reading of the resulting string when compared to Console.WriteLine arguments. You should use Console.WriteLine with arguments only when another method is supplying the format string..
        /// </summary>
        public static string ConsoleWriteLineAnalyzer_Description {
            get {
                return ResourceManager.GetString("ConsoleWriteLineAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Use string interpolation.
        /// </summary>
        public static string ConsoleWriteLineAnalyzer_MessageFormat {
            get {
                return ResourceManager.GetString("ConsoleWriteLineAnalyzer_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Use string interpolation instead of arguments on Console.WriteLine.
        /// </summary>
        public static string ConsoleWriteLineAnalyzer_Title {
            get {
                return ResourceManager.GetString("ConsoleWriteLineAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change to string interpolation.
        /// </summary>
        public static string ConsoleWriteLineCodeFixProvider_Title {
            get {
                return ResourceManager.GetString("ConsoleWriteLineCodeFixProvider_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à An empty catch block suppress all errors and shouldn&apos;t be used.\r\nIf the error is expected consider logging it or changing the control flow such that it is explicit..
        /// </summary>
        public static string EmptyCatchBlockAnalyzer_Description {
            get {
                return ResourceManager.GetString("EmptyCatchBlockAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Empty Catch Block..
        /// </summary>
        public static string EmptyCatchBlockAnalyzer_Message {
            get {
                return ResourceManager.GetString("EmptyCatchBlockAnalyzer_Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Catch block cannot be empty.
        /// </summary>
        public static string EmptyCatchBlockAnalyzer_Title {
            get {
                return ResourceManager.GetString("EmptyCatchBlockAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Insert Exception class to Catch.
        /// </summary>
        public static string EmptyCatchBlockCodeFixProvider_InsertException {
            get {
                return ResourceManager.GetString("EmptyCatchBlockCodeFixProvider_InsertException", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Remove Empty Catch Block.
        /// </summary>
        public static string EmptyCatchBlockCodeFixProvider_Remove {
            get {
                return ResourceManager.GetString("EmptyCatchBlockCodeFixProvider_Remove", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Remove Empty Catch Block and Put a Documentation Link about Try...Catch use.
        /// </summary>
        public static string EmptyCatchBlockCodeFixProvider_RemoveAndDocumentation {
            get {
                return ResourceManager.GetString("EmptyCatchBlockCodeFixProvider_RemoveAndDocumentation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change field type &apos;{0}&apos; accessibility to be as accessible as field &apos;{1}&apos;.
        /// </summary>
        public static string InconsistentAccessibilityInFieldType_Title {
            get {
                return ResourceManager.GetString("InconsistentAccessibilityInFieldType_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change parameter type &apos;{0}&apos; accessibility to be as accessible as indexer &apos;this[{1}]&apos;.
        /// </summary>
        public static string InconsistentAccessibilityInIndexerParameter_Title {
            get {
                return ResourceManager.GetString("InconsistentAccessibilityInIndexerParameter_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change indexer return type &apos;{0}&apos; accessibility to be as accessible as indexer &apos;this[{1}]&apos;.
        /// </summary>
        public static string InconsistentAccessibilityInIndexerReturnType_Title {
            get {
                return ResourceManager.GetString("InconsistentAccessibilityInIndexerReturnType_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change parameter type &apos;{0}&apos; accessibility to be as accessible as method &apos;{1}&apos;.
        /// </summary>
        public static string InconsistentAccessibilityInMethodParameter_Title {
            get {
                return ResourceManager.GetString("InconsistentAccessibilityInMethodParameter_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change return type &apos;{0}&apos; accessibility to be as accessible as method &apos;{1}&apos;.
        /// </summary>
        public static string InconsistentAccessibilityInMethodReturnType_Title {
            get {
                return ResourceManager.GetString("InconsistentAccessibilityInMethodReturnType_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change property type &apos;{0}&apos; accessibility to be as accessible as property &apos;{1}&apos;.
        /// </summary>
        public static string InconsistentAccessibilityInPropertyType_Title {
            get {
                return ResourceManager.GetString("InconsistentAccessibilityInPropertyType_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Make method non async.
        /// </summary>
        public static string MakeMethodNonAsyncCodeFixProvider_Title {
            get {
                return ResourceManager.GetString("MakeMethodNonAsyncCodeFixProvider_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à In C#6 the nameof() operator should be used to specify the name of a program element instead of a string literal as it produce code that is easier to refactor..
        /// </summary>
        public static string NameOfAnalyzer_Description {
            get {
                return ResourceManager.GetString("NameOfAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Use &apos;nameof({0})&apos; instead of specifying the program element name..
        /// </summary>
        public static string NameOfAnalyzer_MessageFormat {
            get {
                return ResourceManager.GetString("NameOfAnalyzer_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Use nameof.
        /// </summary>
        public static string NameOfAnalyzer_Title {
            get {
                return ResourceManager.GetString("NameOfAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Use nameof().
        /// </summary>
        public static string NameOfCodeFixProvider_Title {
            get {
                return ResourceManager.GetString("NameOfCodeFixProvider_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à String interpolation allows for better reading of the resulting string when compared to String.Format. You should use String.Format only when another method is supplying the format string..
        /// </summary>
        public static string StringFormatAnalyzer_Description {
            get {
                return ResourceManager.GetString("StringFormatAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Use string interpolation.
        /// </summary>
        public static string StringFormatAnalyzer_MessageFormat {
            get {
                return ResourceManager.GetString("StringFormatAnalyzer_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Use string interpolation instead of String.Format.
        /// </summary>
        public static string StringFormatAnalyzer_Title {
            get {
                return ResourceManager.GetString("StringFormatAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change to string interpolation.
        /// </summary>
        public static string StringFormatCodeFixProvider_Title {
            get {
                return ResourceManager.GetString("StringFormatCodeFixProvider_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Auto properties offer a more concise way of defining a property. If you are using simple getters and setters you are able to simplify your code with autoproperties..
        /// </summary>
        public static string SwitchToAutoPropAnalyzer_Description {
            get {
                return ResourceManager.GetString("SwitchToAutoPropAnalyzer_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change {0} to an auto property.
        /// </summary>
        public static string SwitchToAutoPropAnalyzer_MessageFormat {
            get {
                return ResourceManager.GetString("SwitchToAutoPropAnalyzer_MessageFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Use auto property.
        /// </summary>
        public static string SwitchToAutoPropAnalyzer_Title {
            get {
                return ResourceManager.GetString("SwitchToAutoPropAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Change to auto property.
        /// </summary>
        public static string SwitchToAutoPropCodeFixProvider_Title {
            get {
                return ResourceManager.GetString("SwitchToAutoPropCodeFixProvider_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à You have missing/unexistent parameters in Xml Docs.
        /// </summary>
        public static string XmlDocumentationAnalyzer_Title {
            get {
                return ResourceManager.GetString("XmlDocumentationAnalyzer_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Create missing parameters in xml docs.
        /// </summary>
        public static string XmlDocumentationCreateMissingParametersCodeFixProvider_Title {
            get {
                return ResourceManager.GetString("XmlDocumentationCreateMissingParametersCodeFixProvider_Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Recherche une chaîne localisée semblable à Remove unexistent parameters in xml docs.
        /// </summary>
        public static string XmlDocumentationRemoveNonExistentParametersCodeFixProvider_Title {
            get {
                return ResourceManager.GetString("XmlDocumentationRemoveNonExistentParametersCodeFixProvider_Title", resourceCulture);
            }
        }
    }
}
